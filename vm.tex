\section{Embedded interpreters}
\label{s:vm}

\input{fig-vms}

\autoref{fig:vms} summarizes embedded interpreters discussed in this paper.
Each interpreter is designed to execute bytecode of a hypothetical machine
that aims at solving problems in a specific domain, as detailed next.

\paragraph{Linux Socket Monitoring Interface (\inetdiag).}
%
The \inetdiag bytecode is designed for socket monitoring.
%filters active sockets in the Linux kernel
%according to the socket state, port numbers, as well as
%source and destiantion addresses.
For example, consider a user invoking the \cc{ss} command~\cite{inetdiag:ss}
from the shell as follows:
\begin{equation*}
\cc{ss 'sport < 1024 or dport = :ssh'}
\end{equation*}
This command monitors sockets with either
source port less than 1024~(i.e., well-known ports)
or destination port 22~(i.e., SSH).
The \cc{ss} command then
generates the following bytecode and submits it to the kernel:
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}]
    \PY{k}{sge} 1024, L1  \PY{c+c1}{# if !(sport >= 1024) goto L1}
    \PY{k}{dge}   22, L2  \PY{c+c1}{# if !(dport >= 22)   goto L2}
    \PY{k}{dle}   22, L2  \PY{c+c1}{# if !(dport <= 22)   goto L2}
L1: \PY{k}{nop}           \PY{c+c1}{# accept}
L2:               \PY{c+c1}{# reject}
\end{Verbatim}
The \inetdiag interpreter executes the bytecode in the kernel
and returns a list of sockets for which the execution
reaches ``accept''~(\cc{nop}).

The \inetdiag bytecode supports comparisons and forward jumps, but not backward
jumps, to avoid loops.  Therefore, the interpreter must check that every jump
offset must be positive.  Failing to reject bytecode that violates this
invariant will lead to infinite loops~(\autoref{s:vuln:loop}).

\paragraph{Berkeley Packet Filter (BPF).}
%
BPF is used in many Unix-like OS kernels to filter link-layer
packets~\cite{mccanne:bpf}.
Recently, the Linux kernel added support for system call filtering
via BPF~\cite{seccomp-bpf}.
BPF uses a register-based virtual machine,
which consists of two registers and a small scratch memory.
The BPF interpreter executes bytecode to check against input data,
and returns a boolean result.
The Linux kernel also includes a JIT compiler for BPF~\cite{corbet:bpf}.
BPF supports integer arithmetic,
logical operations, branches, and forward jumps.
One example of malicious arithmetic operations BPF should prevent
is division by zero;
failing to do so leads to a crash~(\autoref{s:vuln:arith}).
Since the BPF interpreter supports a memory region,
failing to zero the memory before use
will leak information of the host system~(\autoref{s:vuln:leak}).

\paragraph{ACPI Machine Language (AML).}
%
AML~\cite{aml:spec} defines ACPI control methods, which instruct the OS kernel
how to respond to certain power management events.  Because AML bytecode is
usually loaded from the firmware, it is considered trusted and allowed to do
anything, including accessing arbitrary memory, performing device I/O, and
invoking any functions in the kernel. The Linux kernel, however, allows
user-space applications to override some control methods.
If the permission check of this overriding mechanism is insufficient,
an adversary can inject and execute arbitrary code in the
kernel~(\autoref{s:vuln:exec}).

\paragraph{Bitcoin.}
%
Bitcoin uses an interpreter to define transactions over its
network~\cite{bitcoin:script}. The Bitcoin interpreter is a stack machine.
The input, such as public keys, are embedded in its bytecode as
constants. The interpreter returns whether the transaction is valid or
not. Besides conditional branches, arithmetic and logical
operations, the interpreter also supports many string and cryptographic 
operations to validate a transaction.

\paragraph{\clamav.}
%
The \clamav antivirus engine uses LLVM-based bytecode as
signatures for polymorphic malware~\cite{clamav:llvm}.  LLVM is a
register machine that supports arithmetic and logical operations,
branches, jumps, and function calls.  \clamav's interpreter
and JIT engine sandbox the bytecode so that all pointers are
bounds checked, loops have timeouts, and external
function invocations are disallowed.

\paragraph{TrueType and Type 2 Charstring}
%
TrueType defines a hinting language for rendering
fonts~\cite{truetype:intro}. The bytecode manipulates control
points in the font outline. The TrueType VM is a stack machine
that supports arithmetic and logical operations, branches, loops,
and function calls. It also has opcodes to move, align and
interpolate points in various ways. The Type 2 Charstring VM
defined in Adobe Type 2 Font~\cite{type2:spec} is similar to 
TrueType, except that it does not allow jumps and loops.


\paragraph{Universal Decompressor Virtual Machine (UDVM).}
%
UDVM~\cite{udvm:rfc} is used by Wireshark, a packet analyzer, to decompress
certain stream protocols. UDVM has 64KB of memory and a call stack. It supports
arithmetic, logical, and some string operations. These instructions can
reference memory directly. UDVM also supports branches and loops. UDVM imposes
cycle limits on bytecode based on the length of the input data.

\paragraph{\rarvm.}
%
RAR files can contain \rarvm bytecode that performs some
reversible transformation on input data to increase
redundancy~\cite{rar:vm}. \rarvm is an x86-like register machine.
It has 8 registers and 64KB of memory with a stack at the top.
It supports arithmetic and logical operations, branches, loops
and function calls. \rarvm sandboxes its bytecode in a way similar
to \clamav, but allows some external function calls.

\paragraph{Pickle}
%
The Python standard library provides the Pickle~\cite{pickle:vm}
module for serializing and deserializing Python objects. Pickle
protocol defines a stack interpreter, and executes the
bytecode to deserialize Python objects. Pickle's input data is
embedded in its bytecode program.  It has opcodes to manipulate
Python objects such as dictionary and list, and also supports
opcodes to load and invoke external Python libraries.

% Linux kernel: ACPI AML, BPF, INET diag
% App-level: Bitcoin, ClamAV, RegExp
% Rendering: TrueType, PICT, Flash
% Marshaling: UDVM(Wireshark), RAR, Pickle
% 
% VM architecture and features:
% 
% - stack or register machine?
% - has virtual memory / scratch space?
% - how to input / output?
% - control flow support: branchs, jumps, loops (jump backward)?
% - function call and custom function?
% - has support arithmetic and logical operations?
% - has application-specific operations? 
%   (string, hashing, crypto, rasterization, etc.)
